import { MongoServerError } from 'mongodb'

import {
  TaskType,
  ERROR_TASK_STATUS,
  FINISH_RESEARCH_TASK_TYPE,
  FinishResearchTaskData,
  NEW_PLAYER_TASK_TYPE,
  PROCESSED_TASK_STATUS,
  START_RESEARCH_TASK_TYPE,
  StartResearchTaskData,
  TaskData,
  FINISH_BUILD_UNITS_TASK_TYPE,
  START_BUILD_UNITS_TASK_TYPE
} from '../types/ITask'
import taskRepository from '../repositories/taskRepository'
import playerRepository from '../repositories/playerRepository'
import groupTasksBySeconds from '../helpers/groupTasksBySeconds'
import { IPlanetDocument } from '../models/PlanetModel'
import { IPlayerDocument } from '../models/PlayerModel'
import { IUniverseDocument } from '../models/UniverseModel'
import { ITaskDocument, ITaskTypeDocument } from '../models/TaskModel'
import { TASK_HANDLER, TaskHandler } from './tasks/taskHandlers'
import calculateResourceProduction from './resources/calculateResourceProduction'
import computedBonus from './bonus/computedBonus'
import GameEngineError from './errors/GameEngineError'

async function processTasks(tasks: ITaskDocument[], universe: IUniverseDocument) {
  const tasksGroupedBySeconds = groupTasksBySeconds(tasks, universe)

  for (const { tasks, second } of tasksGroupedBySeconds) {
    // 0.- Calculate player resources
    await processResourceProduction(tasks, second)

    // 1.- New player Tasks
    const newPlayerTasks = tasks.filter((task) => task.type === NEW_PLAYER_TASK_TYPE)

    const newPlayerTaskHandler = TASK_HANDLER[NEW_PLAYER_TASK_TYPE].handler

    await processTasksSequentially(newPlayerTasks, newPlayerTaskHandler, second)

    // 2.- Finish Research Tasks
    const finishResearchTaskHandler = TASK_HANDLER[FINISH_RESEARCH_TASK_TYPE].handler

    const finishResearchTasks = tasks.filter((task) => task.type === FINISH_RESEARCH_TASK_TYPE)
    await processTasksInParallel(finishResearchTasks, finishResearchTaskHandler, second)

    // 3.- Start Research Tasks
    const startResearchTaskHandler = TASK_HANDLER[START_RESEARCH_TASK_TYPE].handler

    // we can have new startResearchTasks generated by the finishResearchTaskHandler
    const startResearchTasks = await taskRepository.getPendingTasksByType(
      universe._id,
      second,
      START_RESEARCH_TASK_TYPE
    )
    await processTasksSequentially(startResearchTasks, startResearchTaskHandler, second)

    // 4.- Finish Build Units Tasks
    const finishBuildUnitsTaskHandler = TASK_HANDLER[FINISH_BUILD_UNITS_TASK_TYPE].handler

    const finishBuildUnitsTasks = tasks.filter((task) => task.type === FINISH_BUILD_UNITS_TASK_TYPE)
    await processTasksInParallel(finishBuildUnitsTasks, finishBuildUnitsTaskHandler, second)

    // 5.- Start Build Units Tasks
    const startBuildUnitsTaskHandler = TASK_HANDLER[START_BUILD_UNITS_TASK_TYPE].handler

    const startBuildUnitsTasks = await taskRepository.getPendingTasksByType(
      universe._id,
      second,
      START_BUILD_UNITS_TASK_TYPE
    )
    await processTasksSequentially(startBuildUnitsTasks, startBuildUnitsTaskHandler, second)

    // update universe
    universe.lastProcessedTime = second
    await universe.save()
  }
}

export default processTasks

// TODO: add tests here
async function processTasksSequentially<Type extends TaskType>(
  tasks: ITaskDocument[],
  handler: TaskHandler<Type>,
  second: number
) {
  for (const task of tasks) {
    await setTaskAsProcessed(task, handler, second)
  }
}

async function processTasksInParallel<Type extends TaskType>(
  tasks: ITaskDocument[],
  handler: TaskHandler<Type>,
  second: number
) {
  return Promise.all(tasks.map((task) => setTaskAsProcessed(task, handler, second)))
}

async function setTaskAsProcessed<Type extends TaskType>(
  task: ITaskDocument,
  handler: TaskHandler<Type>,
  second: number
) {
  const startTime = new Date().getTime()
  try {
    await handler(task as ITaskTypeDocument<Type>, second)
    task.status = PROCESSED_TASK_STATUS
    task.history.push({ taskStatus: PROCESSED_TASK_STATUS, updatedAt: new Date().getTime() })
  } catch (error) {
    // TODO: create a task.error as an object
    // task.error.message
    // task.error.details
    // task.error.extraData

    task.errorDetails = (error as Error)?.message

    if (error?.constructor?.name === 'MongoServerError') {
      const mongoError = error as MongoServerError
      task.errorDetails = mongoError.message
    }
    if (error instanceof GameEngineError) {
      task.errorDetails = error.message
    }

    task.status = ERROR_TASK_STATUS
    task.history.push({ taskStatus: ERROR_TASK_STATUS, updatedAt: new Date().getTime() })
  }

  task.isCancellable = false
  task.processedAt = second
  const endTime = new Date().getTime()
  task.processingDuration = endTime - startTime
  return task.save()
}

async function processResourceProduction(
  tasks: ITaskTypeDocument<TaskType>[],
  second: number
): Promise<IPlanetDocument[]> {
  const planets: {
    planet: IPlanetDocument
    owner: IPlayerDocument
  }[] = []

  // TODO: implement targetPlanet feature
  for (const task of tasks) {
    // calculate all player planet production
    if (isPlayerTaskData(task.data)) {
      const player = await playerRepository.findPlayerById(task.data.playerId)

      if (player) {
        const playerPlanets = player.planets.colonies

        playerPlanets.forEach((playerPlanet) => {
          const isAlreadyIncluded = planets.some(({ planet }) =>
            planet._id.equals(playerPlanet._id)
          )

          if (!isAlreadyIncluded) {
            planets.push({
              planet: playerPlanet,
              owner: player
            })
          }
        })
      }
    }
  }

  return Promise.all(
    planets.map(({ planet, owner }) => {
      const ownerResourceProductionBonus = computedBonus(owner.perks, 'RESOURCE_PRODUCTION_BONUS')

      planet.resources = calculateResourceProduction(
        second,
        planet.resources,
        planet.lastResourceProductionTime,
        planet.resourceQuality,
        ownerResourceProductionBonus
      )
      planet.lastResourceProductionTime = second

      return planet.save()
    })
  )
}

function isPlayerTaskData(
  taskData: TaskData<TaskType>
): taskData is StartResearchTaskData | FinishResearchTaskData {
  return 'player' in taskData
}
